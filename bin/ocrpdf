#!/usr/bin/env bash

# -----------------------------------------------------------------------------
# A utility to run a scanned PDF through tesseract's OCR engine and make it
# searchable.
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Author:        Urs Roesch <github@bun.ch>
# License:       MIT
# Requires:      bash, pdfcat, pdfimages (poppler-utils), pdftk, tesseract
# -----------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Settings
# ------------------------------------------------------------------------------
set -o nounset
set -o errexit
set -o pipefail

trap cleanup EXIT

# ------------------------------------------------------------------------------
# Globals
# ------------------------------------------------------------------------------
declare -r SCRIPT=${0##*/}
declare -r VERSION=0.3.2
declare -r AUTHOR="Urs Roesch <github@bun.ch>"
declare -r LICENSE="MIT"
declare -a PDF_FILES=()
declare    EXTENSION=pdf
declare -g RENDER_FORMAT='png'
declare -g REPLACE=false
declare -g SUFFIX=${SCRIPT}
declare -a INCLUDES=(
  pdfcat
)
declare -a DEPENDENCIES=(
  pdfcat
  pdfimages
  pdftocairo
  pdftk
  tesseract
)

# ------------------------------------------------------------------------------
# Functions
# ------------------------------------------------------------------------------

function check_dependencies() {
  for dependency in ${DEPENDENCIES[@]}; do
    if ! command -v ${dependency} >/dev/null 2>&1; then
      echo "Missing dependency '${dependency}'" 1>&2
      echo "Please install to use this script!" 1>&2
      exit 64
    fi
  done
}

# ------------------------------------------------------------------------------

function source_includes() {
  for include in ${INCLUDES[@]}; do
    local path=$(command -v ${include} 2>/dev/null)
    [[ -n ${path} ]] && source ${path}
  done
}

# ------------------------------------------------------------------------------

function determine_ocr_languages() {
  OCR_LANG=$(
    sed 's/ /+/g' <<< $( echo $( tesseract --list-langs 2>&1 | grep "^...$" ) )
  )
}

# ------------------------------------------------------------------------------

function run_ocr() {
  local filename="${1}"; shift;
  tesseract -l ${OCR_LANG} "${filename}" "${filename%%.*}" pdf >/dev/null 2>&1
  if [[ $? -eq 0 ]]; then
    rm "${filename}"
  else
    echo "An error occured during character recogntion." 1>&2
    echo "Please investigate!" 1>&2
    echo "Leaving original image '${filename}' intact" 1>&2
    exit 128
  fi
}

# ------------------------------------------------------------------------------

function version() {
  printf "%s v%s\nCopyright (c) %s\nLicense - %s\n" \
    "${SCRIPT}" "${VERSION}" "${AUTHOR}" "${LICENSE}"
  exit 0
}

# ------------------------------------------------------------------------------

function usage() {
  local exit_code=${1:-}
  cat <<USAGE

  Usage:
    ${SCRIPT} [options] <file> [<file> [,,]]

  Options:
    -h | --help           This message
    -V | --version        Print version information and exit
    -r | --replace        Replace the input PDF with the OCRed version.
    -l | --lang <lang>    Set the OCR languages to use.
                          For multiple languages concatenate with a '+'
                          E.g eng+deu for English and German
                          Default: ${OCR_LANG}
    -F | --render-format <format> 
                         When rendering is switched on convert either to 
                         jpeg or png before running through OCR.
                         default: ${RENDER_FORMAT}
    -s | --suffix <suffix> 
                         Set a suffix to be appended to the file's 
                         basename. Implies '-r'. 
                         default: ${SUFFIX}

  Description:
    Runs PDFs through OCR and saves the output as a text searchable PDF
    with the same name.

  Disclaimer:
    Only works with quality degradation for PDFs comprised of a single
    JPEG, LZW or deflated image per page.
    LZW compressed images will be converted to deflated ones during
    the OCR process but there is no loss of fidelity.
    Composite images with multiple layers as JBIG2, CCITT or SMASKS
    are rendered as a flat image before running through OCR. The
    resulting PDFs are suffixed with '-${SCRIPT}.pdf' preserving the
    original file.

USAGE
  exit ${exit_code}
}

# ------------------------------------------------------------------------------

function check_compatibility() {
  local file="${1}"; shift;
  ## check if all the images are single jpegs
  pdfimages -list "${file}" | \
    awk \
      '/^ +[0-9]/{p=$1; c++; $9 ~ /^(jpeg|image)$/ && j++ }
       END { if (p < c && p == j) {exit 1} }'
}

# ------------------------------------------------------------------------------

function determine_filename() {
  local file=$1; shift;
  if [[ ${REPLACE} == false ]]; then
    file="${file%.*}-${SUFFIX}.pdf"
  fi
  echo ${file}
}

# -----------------------------------------------------------------------------

function ocr_pdfs() {
  for file in "${PDF_FILES[@]}"; do
    local workname="$$-${RANDOM}"
    local meta="$(fetch_meta "${file}")"
    if ! check_compatible "${file}"; then
      pdftocairo -q -${RENDER_FORMAT} "${file}" "${workname}" 2>/dev/null
    else
      pdfimages -all "${file}" "${workname}" 2>/dev/null
    fi &&
      for image in ${workname}*; do
        run_ocr ${image}
      done
    post_process_pdf "$(determine_filename "${file}")" "${workname}" "${meta}"
  done
}

# ------------------------------------------------------------------------------

function post_process_pdf() {
  local file="${1}"; shift;
  local workname="${1}"; shift;
  local meta="${1}"; shift;
  merge_pdf "${workname}.${EXTENSION}" ${workname}*
  pdftk "${workname}.pdf" \
    update_info_utf8 <( echo "${meta}" ) \
    output "${file}" 2>/dev/null
  rm "${workname}.pdf"
}

# ------------------------------------------------------------------------------

function merge_pdf() {
  local filename="${1}"; shift;
  local documents=( "${@}" ); shift;
  if [[ ${#documents[@]} -eq 1 ]]; then
    mv "${documents[0]}" "${filename}" 2>/dev/null
  else
    pdfcat::concat_pdf "${documents[@]}" > "${filename}" &&
      rm "${documents[@]}" 2>/dev/null
  fi
}

# ------------------------------------------------------------------------------

function parse_options() {
 [[ ${#} -lt 1 ]] && usage 1
  while [[ ${#} -gt 0 ]]; do
    case ${1} in
    -F|--render-format)  shift; RENDER_FORMAT=$1;;
    -h|--help)           usage 0;;
    -l|--lang)           shift; OCR_LANG=$1;;
    -s|--suffix)         shift; SUFFIX=$1;;
    -r|--replace)        REPLACE=$1;;
    -V|--version)        version;;
    *)                   PDF_FILES+=( "${1}" );;
    esac
    shift
  done
}

# ------------------------------------------------------------------------------

function evaluate_opts() {
  case ${RENDER_FORMAT} in
    png|jpeg) return 0;;
    *)        usage 1;;
  esac
}


# -----------------------------------------------------------------------------

function cleanup() {
  local exit_code=$?
  rm $$-[0-9]*.{jpg,pdf} 2>/dev/null || :
  exit ${exit_code}
  exit_code="$?"
}

# ------------------------------------------------------------------------------
# Main
# ------------------------------------------------------------------------------
check_dependencies
source_includes
determine_ocr_languages
parse_options "${@}"
set_ocr_language
parse_opts "$@"
evaluate_opts
ocr_pdfs
