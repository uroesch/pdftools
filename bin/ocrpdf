#!/bin/bash

## ----------------------------------------------------------------------------
## A utility to run a scanned PDF through tesseract's OCR engine and make it
## searchable.
## ----------------------------------------------------------------------------

## ----------------------------------------------------------------------------
## Author:        Urs Roesch <github@bun.ch>
## License:       MIT
## Requires:      bash, pdfcat, pdfimages (poppler-utils), pdftk, tesseract
## ----------------------------------------------------------------------------

## -----------------------------------------------------------------------------
## Settings
## -----------------------------------------------------------------------------
trap cleanup EXIT
set -o nounset
set -o errexit

## -----------------------------------------------------------------------------
## GLOBALS
## -----------------------------------------------------------------------------
VERSION=0.2
SCRIPT=${0##*/}
DEPENDENCIES=(
  pdfcat
  pdfimages
  pdftocairo
  pdftk
  tesseract
)
INCLUDES=(
  pdfcat
)
PDF_FILES=()
REPLACE=false
RENDER_FORMAT='png'
SUFFIX=${SCRIPT}

## -----------------------------------------------------------------------------
## FUNCTIONS
## -----------------------------------------------------------------------------

check_dependencies() {
  for dependency in ${DEPENDENCIES[*]}; do
    if ! which ${dependency} >/dev/null 2>&1; then
      echo "Missing dependency '${dependency}'" 1>&2
      echo "Please install to use this script!" 1>&2
      exit 64
    fi
  done
}

## -----------------------------------------------------------------------------

source_includes() {
  for include in ${INCLUDES[*]}; do
    local path=$( which ${include} 2>/dev/null )
    [[ -n ${path} ]] && source ${path}
  done
}

## -----------------------------------------------------------------------------

set_ocr_language() {
  OCR_LANG=$(
    sed 's/ /+/g' <<< $( echo $( tesseract --list-langs 2>&1 | grep "^...$" ) )
  )
}

## -----------------------------------------------------------------------------

run_ocr() {
  local filename="$1"; shift;
  tesseract -l ${OCR_LANG} "${filename}" "${filename%%.*}" pdf >/dev/null 2>&1
  if [[ $? -eq 0 ]]; then
    rm "${filename}"
  else
    echo "An error occured during character recogntion" 1>&2
    echo "Leaving original image '${filename}' intact" 1>&2
    exit 128
  fi
}

## -----------------------------------------------------------------------------

print_version() {
  echo ${SCRIPT} version ${VERSION}
  exit 0
}

## -----------------------------------------------------------------------------

usage() {
  local exit_code=$1
  cat <<USAGE

  Usage:
    ${SCRIPT} [options] <file> [<file> [,,]]

  Options:
    -h | --help          This message.
    -l | --lang          Set the OCR language for multiple concatenate with 
                         a +. E.g eng+deu for English and German.
                         default: ${OCR_LANG}
    -r | --replace       Replace the input PDF with the OCRed version.
    -F | --render-format <format> 
                         When rendering is switched on convert either to 
                         jpeg or png before running through OCR.
                         default: ${RENDER_FORMAT}
    -s | --suffix <suffix> 
                         Set a suffix to be appended to the file's 
                         basename. Implies '-r'. 
                         default: ${SUFFIX}
    -V | --version       Print version information and exit.

  Description:
    Runs PDFs through OCR and saves the output as a text searchable PDF
    with the same name.

  Disclaimer:
    Only works with quality degradation for PDFs comprised of a single
    JPEG, LZW or deflated image per page.
    LZW compressed images will be converted to deflated ones during
    the OCR process but there is no loss of fidelity.
    Composite images with multiple layers as JBIG2, CCITT or SMASKS
    are rendered as a flat image before running through OCR. The
    resulting PDFs are suffixed with '-${SCRIPT}.pdf' preserving the
    original file.

USAGE
  exit ${exit_code}
}

## -----------------------------------------------------------------------------

check_compatible() {
  local file="$1"; shift;
  ## check if all the images are single jpegs
  pdfimages -list "${file}" | awk \
    '/^ +[0-9]/{p=$1; c++; $9 ~ /^(jpeg|image)$/ && j++ }
    END { if (p < c && p == j) {exit 1} }'
}

## -----------------------------------------------------------------------------

determine_filename() {
  local file=$1; shift;
  if [[ ${REPLACE} == false ]]; then
    file="${file%.*}-${SUFFIX}.pdf"
  fi
  echo ${file}
}

## -----------------------------------------------------------------------------

ocr_pdfs() {
  for file in "${PDF_FILES[@]}"; do
    local workname="$$-${RANDOM}"
    local meta="$(fetch_meta "${file}")"
    if ! check_compatible "${file}"; then
      pdftocairo -q -${RENDER_FORMAT} "${file}" "${workname}" 2>/dev/null
    else
      pdfimages -all "${file}" "${workname}" 2>/dev/null
    fi &&
      for image in ${workname}*; do
        run_ocr ${image}
      done
    post_process_pdf "$(determine_filename "${file}")" "${workname}" "${meta}"
  done
}

## -----------------------------------------------------------------------------

post_process_pdf() {
  local file="$1"; shift;
  local workname="$1"; shift;
  local meta="$1"; shift;
  merge_pdf "${workname}.pdf" ${workname}*
  pdftk "${workname}.pdf" \
    update_info_utf8 <( echo "${meta}" ) \
    output "${file}" 2>/dev/null
  rm "${workname}.pdf"
}

## -----------------------------------------------------------------------------

merge_pdf() {
  local filename="$1"; shift;
  local documents=( "$@" ); shift;
  if [[ ${#documents[@]} -eq 1 ]]; then
    mv "${documents[0]}" "${filename}" 2>/dev/null
  else
    concat_pdf "${documents[@]}" > "${filename}.${EXTENSION}" &&
      rm "${documents[@]}" 2>/dev/null
  fi
}

## -----------------------------------------------------------------------------

parse_opts() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      -F|--render-format)  shift; RENDER_FORMAT=$1;;
      -h|--help)           usage 0;;
      -l|--lang)           shift; OCR_LANG=$1;;
      -s|--suffix)         shift; SUFFIX=$1;;
      -r|--replace)        REPLACE=$1;;
      -V|--version)        print_version;;
      *)                   PDF_FILES=( "${PDF_FILES[@]}" "$1" );;
    esac
    shift
  done
}

## -----------------------------------------------------------------------------

evaluate_opts() {
  case ${RENDER_FORMAT} in
    png|jpeg) return 0;;
    *)        usage 1;;
  esac
}


## -----------------------------------------------------------------------------

cleanup() {
  exit_code="$?"
  rm $$-[0-9]*.{jpg,pdf} 2>/dev/null || return ${exit_code}
}

## -----------------------------------------------------------------------------
## MAIN
## -----------------------------------------------------------------------------
check_dependencies
source_includes
set_ocr_language
parse_opts "$@"
evaluate_opts
ocr_pdfs
